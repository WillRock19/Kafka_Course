*
* 													CLASS 01_Batch
* 
* 
* 	In a situation where we generate reports, we might want to use messages in batch. We've starting this
* 	class discussing the subject and creating a new service, "service-reading-report", to generate this 
*	kind of report.
*	
*	Then, we will create a new service, that will be responsible for creating a reports in batch (imagine 
*	it as a service that will run monthly and generate reports for every single user we have in this DB).
*	
*	1. About the GenerateAllReportsServlet file
*	
*		This servlet was created to trigger the report generation for many users in a single row. With that being said,
*		let's think: our servelet will receive an HTTP request that shall trigger the generation of reports, but, as we've
*		discussed in the Course 02, I want to send that data as fast as I can to the brokers, so I don't fall into the 
*		problem of something goes wrong and I loose those data inside my servlet, or, even worst, I generate messages for
*		part of the users I've received, and not all of them (them, in the frontend, my user may use F5 in the page, and
*		the full process might be triggered again).
*
*		So, I must do something like a Fast Delegate, and give that messages to someone as fast as I can. How? 
*		
*	
*			The way we are going to do it is: I receive the request in the servlet, send ONE single message to the brokers 
*			telling them to "generate all reports" and then send, as fast as I possibly can, an answer to the frontend 
*			with an OK status;  
*		
*			  	The problem: in this new service, I won't have the user's ids I've received with the HTTP request
*							 on the GenerateAllReportsServlet. So, how to deal with this? There are some ways...
*		
*					1. In the new service, I make an HTTP request to OTHER service, asking the users Ids... and await the		
*					   answer before proceed (since the user won't be awaiting the answer no more... this could be an OK
*					   approach).
*		
*					2. In the new service, I could access the database from the CreateUsers's service to find all the ids
*					   (not that good because I make two services depends on a single database... but valid, depending on
*					   the situation);
*
*					3. In the new service, I can storage a list of users ids. To do so, we could send a message to the broker
*					   each time a user is registered in my database inside the service-create-user, and this new service could
*					   be a consumer to that messages, saving locally each of those user's data so it always has a list of users's
*					   ids to generate the full report (it may generate some other problems, as generate messages when the user
*					   is deleted, so my list of user ids may always be valid).
*
*					4. From the GenerateAllReportsServlet, I can execute a "task dispatcher", that will send a message with a task
*					   to be executed from all users. This will be the approach we shall execute in this class.
*
*					   	So, to do this we created the BatchSendMessageService, a Kafka's consumer that will listen to messages of 
*						the type SEND_MESSAGE_TO_ALL_USERS and send any topics that may come with this message to all existing users
*						in our database. 
*						
*						Since we are using it to send a USER_GENERATE_READING_REPORT for all users, it will send it a message to this
*						topic in our broker, and the consumer we've already created in the start of this class, the ReadingReportService,
*						will listen to it and generate a report for each of the users it receive.
*
*
*
* 													CLASS 02_Customized Serialization and Deserialization
*
*	1. The importance of the CorrelationId
*
*		There are still errors happening here and there. Think about it: we have an HTTP Server that will receive a request and send
*		a message, that the broker will hear and a consumer will consume; the consumer will then send ANOTHER message to the broker,
*		that yet ANOTHER consumer will hear, and only then that last one will generate the reports as we want. So... how can we track
*		that process, so we may know which message comes from where? We need to know that, because an exception may occur in any part
*		of this process (or even another one, that may be larger or have even more services in between), and we need to have a way to
*		track what started the process where the exception happened.
*
*		To do that, we need a identification for the messages that we are generating, and that id must be created in the first moment
*		the process started, and keep being pass forward through each of the services that will be triggered by that first one.
*
*		That's what we are going to do in this class.
*
*
*	2. Setting up a CorrelationId
*
*		Since the correlationId will be something that every message must have, we can implement it in some ways:
*
*			1. Using the header's system that Kafka give us and put it in there;
*			2. Creating a class to wrap the message and the correlationId in a single place;
*
*		Here, we are going to do the second option.
*
*
*	3. Implementing the Correlation Id
*	
*		So, to really put the correlationId concept to use, we need to create it when we dispatch messages. But not only that; with the
*		id, we want to send a text telling where the process started, so we have a breadcrumb from where to start looking if something
*		goes wrong. 
*
*		So, the first change we are going to make is change our KafkaDispatcher to add this identifier in it.
*	
*		Now that we are adding the service that dispatch the message, we want to concatenate informations that comes from other service
*		to the current before dispatch again. What do I mean? Imagine we dispatch a message in the HttpClient. Then, our BatchSendMessage
*		will hear it ang generate a new dispatch, that will trigger the report generation for each user. In this case, we will concatenate
*		the info that came with the HTTP service with the info from the Batch service before dispatch it again, and keep doing it for any
*		services that comes in our way.

*		THis way, our correlationId will become a breadcrumb... and we might be able to use it at our favor at any time.
*
*		To do this, the first step will be turn the creation of the correlationId something required to each sender, so the people who use
*		the dispatchers will always know that info NEEDS to be there, so we may create our breadcrumb.
*
*		Then, since the services will be responsible for instantiating the CorrelationId, we can use it to our advantage to associate the
*		existing one, that our server might have received in it's method, with the new one, that it must send with the message that goes 
*		to the broker
*
* 		If we have any async requests in the middle of the service-calling-service road, we might want to add it in the CorrelationId too,
*		so we can have the best breadcrumb ever! :D
*
*
*
*
*